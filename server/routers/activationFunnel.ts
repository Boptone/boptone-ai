/**
 * GROWTH-5: Artist Activation Funnel Router
 *
 * Drives new artists from signup → first revenue-generating action within 24 hours.
 * 7 steps, LLM-personalized hints, real-time completion tracking, self-dismissing widget.
 *
 * Architecture:
 * - Steps are seeded once per artist (idempotent) after onboarding completes
 * - Each step gets a personalized hint generated by the LLM using the artist's Toney profile
 * - Steps auto-complete when the underlying action is detected (via markStepComplete)
 * - The dashboard widget hides permanently once all steps are completed or skipped
 */

import { z } from "zod";
import { and, eq, inArray } from "drizzle-orm";
import { protectedProcedure, router } from "../_core/trpc";
import { getDb } from "../db";
import { artistActivationSteps, artistProfiles, artistToneyProfiles } from "../../drizzle/schema";
import { invokeLLM } from "../_core/llm";

// ─── Step Definitions ─────────────────────────────────────────────────────────

export const ACTIVATION_STEPS = [
  {
    key: "complete_profile",
    title: "Complete your artist profile",
    description: "Add a bio, photo, and social links so fans know who you are.",
    order: 1,
    ctaLabel: "Edit Profile",
    ctaPath: "/profile/edit",
  },
  {
    key: "upload_first_track",
    title: "Upload your first track",
    description: "Get your music on Boptone and start earning BAP stream revenue.",
    order: 2,
    ctaLabel: "Upload Track",
    ctaPath: "/bops/upload",
  },
  {
    key: "setup_bopshop",
    title: "Open your BopShop",
    description: "Create a product — merch, beats, presets, or anything you sell.",
    order: 3,
    ctaLabel: "Create Product",
    ctaPath: "/bopshop/products/new",
  },
  {
    key: "enable_kick_in",
    title: "Enable Kick In tips",
    description: "Let fans support you directly with a tip. Takes 60 seconds to activate.",
    order: 4,
    ctaLabel: "Enable Tips",
    ctaPath: "/kickin/setup",
  },
  {
    key: "setup_payouts",
    title: "Connect your bank account",
    description: "Link a bank account so you can receive payouts when you earn.",
    order: 5,
    ctaLabel: "Set Up Payouts",
    ctaPath: "/settings/payouts",
  },
  {
    key: "share_profile",
    title: "Share your Boptone profile",
    description: "Send your profile link to fans or post it on social media.",
    order: 6,
    ctaLabel: "Share Profile",
    ctaPath: "/profile",
  },
  {
    key: "first_revenue",
    title: "Earn your first dollar",
    description: "Receive a tip, make a sale, or earn a stream payment.",
    order: 7,
    ctaLabel: "View Earnings",
    ctaPath: "/finance",
  },
] as const;

export type ActivationStepKey = (typeof ACTIVATION_STEPS)[number]["key"];

// ─── LLM Personalization ──────────────────────────────────────────────────────

async function generatePersonalizedHints(
  artistId: number,
  stepKeys: string[]
): Promise<Record<string, string>> {
  const db = await getDb();
  if (!db) return {};

  try {
    // Fetch artist's Toney profile for personalization context
    const [toneyProfile] = await db
      .select()
      .from(artistToneyProfiles)
      .where(eq(artistToneyProfiles.artistProfileId, artistId))
      .limit(1);

    const context = toneyProfile
      ? `Career stage: ${toneyProfile.careerStage}. Primary genre: ${toneyProfile.primaryGenre}. Active goals: ${toneyProfile.activeGoals || "not specified"}. Primary income source: ${toneyProfile.primaryIncomeSource || "not specified"}.`
      : "New artist, no profile data yet.";

    const stepsToPersonalize = ACTIVATION_STEPS.filter((s) => stepKeys.includes(s.key));

    const prompt = `You are Toney, Boptone's AI advisor for artists. Personalize a short, encouraging hint (max 2 sentences, no fluff) for each activation step below based on this artist's profile.

Artist context: ${context}

Steps to personalize:
${stepsToPersonalize.map((s, i) => `${i + 1}. [${s.key}] "${s.title}" — ${s.description}`).join("\n")}

Return ONLY a JSON object with step keys as keys and personalized hints as values. Example: {"complete_profile": "Your hint here.", "upload_first_track": "Your hint here."}`;

    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content:
            "You are Toney, Boptone's AI advisor. Return only valid JSON with no markdown, no code blocks, no explanation.",
        },
        { role: "user", content: prompt },
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "activation_hints",
          strict: true,
          schema: {
            type: "object",
            properties: Object.fromEntries(
              stepsToPersonalize.map((s) => [s.key, { type: "string" }])
            ),
            required: stepsToPersonalize.map((s) => s.key),
            additionalProperties: false,
          },
        },
      },
    });

    const rawContent = response?.choices?.[0]?.message?.content;
    const content = typeof rawContent === "string" ? rawContent : null;
    if (!content) return {};
    return JSON.parse(content) as Record<string, string>;
  } catch (err) {
    console.error("[ActivationFunnel] Failed to generate personalized hints:", err);
    return {};
  }
}

// ─── Router ───────────────────────────────────────────────────────────────────

export const activationFunnelRouter = router({
  /**
   * Get the artist's activation steps. Seeds them on first call (idempotent).
   * Returns steps sorted by order with completion status and personalized hints.
   */
  getSteps: protectedProcedure.query(async ({ ctx }) => {
    const db = await getDb();
    if (!db) return { steps: [], allComplete: false, completedCount: 0, totalCount: 0 };

    // Get artist profile
    const [artistProfile] = await db
      .select({ id: artistProfiles.id })
      .from(artistProfiles)
      .where(eq(artistProfiles.userId, ctx.user.id))
      .limit(1);

    if (!artistProfile) {
      return { steps: [], allComplete: false, completedCount: 0, totalCount: ACTIVATION_STEPS.length };
    }

    const artistId = artistProfile.id;

    // Fetch existing steps
    const existing = await db
      .select()
      .from(artistActivationSteps)
      .where(eq(artistActivationSteps.artistId, artistId));

    const existingKeys = new Set(existing.map((s) => s.stepKey));
    const missingSteps = ACTIVATION_STEPS.filter((s) => !existingKeys.has(s.key));

    // Seed missing steps (first-time or new steps added to the funnel)
    if (missingSteps.length > 0) {
      const missingKeys = missingSteps.map((s) => s.key);
      const hints = await generatePersonalizedHints(artistId, missingKeys);

      const toInsert = missingSteps.map((step) => ({
        artistId,
        stepKey: step.key,
        stepTitle: step.title,
        stepDescription: step.description,
        stepOrder: step.order,
        status: "pending" as const,
        personalizedHint: hints[step.key] ?? null,
        ctaLabel: step.ctaLabel,
        ctaPath: step.ctaPath,
      }));

      // Insert in batches to avoid duplicate key errors on concurrent requests
      for (const row of toInsert) {
        try {
          await db.insert(artistActivationSteps).values(row).onDuplicateKeyUpdate({
            set: { stepTitle: row.stepTitle, stepDescription: row.stepDescription },
          });
        } catch {
          // Silently skip — already exists
        }
      }

      // Re-fetch all steps after seeding
      const refreshed = await db
        .select()
        .from(artistActivationSteps)
        .where(eq(artistActivationSteps.artistId, artistId));

      const sorted = refreshed.sort((a, b) => a.stepOrder - b.stepOrder);
      const completedCount = sorted.filter((s) => s.status === "completed").length;
      const allComplete = sorted.every((s) => s.status === "completed" || s.status === "skipped");

      return { steps: sorted, allComplete, completedCount, totalCount: sorted.length };
    }

    const sorted = existing.sort((a, b) => a.stepOrder - b.stepOrder);
    const completedCount = sorted.filter((s) => s.status === "completed").length;
    const allComplete = sorted.every((s) => s.status === "completed" || s.status === "skipped");

    return { steps: sorted, allComplete, completedCount, totalCount: sorted.length };
  }),

  /**
   * Mark a specific step as completed. Called from feature flows (upload, sale, etc.)
   * Idempotent — safe to call multiple times.
   */
  markStepComplete: protectedProcedure
    .input(z.object({ stepKey: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) return { success: false };

      const [artistProfile] = await db
        .select({ id: artistProfiles.id })
        .from(artistProfiles)
        .where(eq(artistProfiles.userId, ctx.user.id))
        .limit(1);

      if (!artistProfile) return { success: false };

      await db
        .update(artistActivationSteps)
        .set({ status: "completed", completedAt: new Date() })
        .where(
          and(
            eq(artistActivationSteps.artistId, artistProfile.id),
            eq(artistActivationSteps.stepKey, input.stepKey)
          )
        );

      return { success: true };
    }),

  /**
   * Skip a step — artist explicitly dismisses it.
   */
  skipStep: protectedProcedure
    .input(z.object({ stepKey: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) return { success: false };

      const [artistProfile] = await db
        .select({ id: artistProfiles.id })
        .from(artistProfiles)
        .where(eq(artistProfiles.userId, ctx.user.id))
        .limit(1);

      if (!artistProfile) return { success: false };

      await db
        .update(artistActivationSteps)
        .set({ status: "skipped" })
        .where(
          and(
            eq(artistActivationSteps.artistId, artistProfile.id),
            eq(artistActivationSteps.stepKey, input.stepKey)
          )
        );

      return { success: true };
    }),

  /**
   * Dismiss the entire activation widget (marks all remaining steps as skipped).
   * Used when artist clicks "I'm all set" or "Dismiss".
   */
  dismissAll: protectedProcedure.mutation(async ({ ctx }) => {
    const db = await getDb();
    if (!db) return { success: false };

    const [artistProfile] = await db
      .select({ id: artistProfiles.id })
      .from(artistProfiles)
      .where(eq(artistProfiles.userId, ctx.user.id))
      .limit(1);

    if (!artistProfile) return { success: false };

    await db
      .update(artistActivationSteps)
      .set({ status: "skipped" })
      .where(
        and(
          eq(artistActivationSteps.artistId, artistProfile.id),
          inArray(artistActivationSteps.status, ["pending", "in_progress"])
        )
      );

    return { success: true };
  }),

  /**
   * Regenerate personalized hints for all pending steps.
   * Called when artist updates their Toney profile.
   */
  refreshHints: protectedProcedure.mutation(async ({ ctx }) => {
    const db = await getDb();
    if (!db) return { success: false };

    const [artistProfile] = await db
      .select({ id: artistProfiles.id })
      .from(artistProfiles)
      .where(eq(artistProfiles.userId, ctx.user.id))
      .limit(1);

    if (!artistProfile) return { success: false };

    const pendingSteps = await db
      .select({ stepKey: artistActivationSteps.stepKey })
      .from(artistActivationSteps)
      .where(
        and(
          eq(artistActivationSteps.artistId, artistProfile.id),
          inArray(artistActivationSteps.status, ["pending", "in_progress"])
        )
      );

    if (pendingSteps.length === 0) return { success: true };

    const keys = pendingSteps.map((s) => s.stepKey);
    const hints = await generatePersonalizedHints(artistProfile.id, keys);

    for (const [key, hint] of Object.entries(hints)) {
      await db
        .update(artistActivationSteps)
        .set({ personalizedHint: hint })
        .where(
          and(
            eq(artistActivationSteps.artistId, artistProfile.id),
            eq(artistActivationSteps.stepKey, key)
          )
        );
    }

    return { success: true };
  }),
});
